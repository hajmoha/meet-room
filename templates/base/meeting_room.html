{% extends 'main.html' %}
{% load static %}

{% block title %}Meeting Room - {{ reservation.title }}{% endblock %}

{% block extra_css %}
<style>
    /* General Styles */
    .meeting-container {
        background-color: #f8f9fa;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
        overflow: hidden;
        margin-bottom: 20px;
    }
    
    .meeting-header {
        background: linear-gradient(135deg, #4a6bff 0%, #2541b2 100%);
        color: white;
        padding: 20px;
        position: relative;
    }
    
    .meeting-title {
        font-weight: 700;
        margin-bottom: 5px;
    }
    
    .meeting-info {
        opacity: 0.9;
        font-size: 0.9rem;
    }
    
    .meeting-actions {
        position: absolute;
        top: 20px;
        right: 20px;
    }
    
    /* Chat Styles */
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 500px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
        overflow: hidden;
    }
    
    .chat-header {
        padding: 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        font-weight: 600;
    }
    
    .chat-messages, .chat-log {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background-color: #fff;
        height: 300px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #f9f9f9;
    }
    
    .message {
        margin-bottom: 15px;
        max-width: 80%;
        position: relative;
        padding: 8px;
        border-radius: 5px;
    }
    
    .message-mine, .chat-message-own {
        margin-left: auto;
        background-color: #e3f2fd;
        border-radius: 18px 18px 0 18px;
        padding: 12px 15px;
        color: #0d47a1;
    }
    
    .message-others, .chat-message {
        margin-right: auto;
        background-color: #f5f5f5;
        border-radius: 18px 18px 18px 0;
        padding: 12px 15px;
        color: #333;
        max-width: 80%;
    }
    
    .chat-message-own {
        margin-left: auto;
        background-color: #f1f8e9;
    }
    
    .message-header, .message-sender {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 0.85rem;
        font-weight: 600;
    }
    
    .message-username {
        font-weight: bold;
    }
    
    .message-time {
        font-size: 0.7rem;
        color: #6c757d;
        position: absolute;
        bottom: -18px;
        right: 5px;
    }
    
    .message-system {
        text-align: center;
        margin: 10px 0;
        font-size: 0.85rem;
        color: #6c757d;
        font-style: italic;
    }
    
    .chat-input-container {
        padding: 15px;
        background-color: #f8f9fa;
        border-top: 1px solid #e9ecef;
    }
    
    .chat-input {
        border-radius: 30px;
        padding-left: 20px;
        border: 1px solid #ced4da;
    }
    
    .chat-send-btn {
        border-radius: 50%;
        width: 40px;
        height: 40px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Participants Styles */
    .participants-container {
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
        overflow: hidden;
        height: 500px;
    }
    
    .participants-header {
        padding: 15px;
        background-color: #4a4b4d;
        border-bottom: 1px solid #e9ecef;
        font-weight: 600;
        color: white;
    }
    
    .participants-list {
        overflow-y: auto;
        height: calc(100% - 53px);
    }
    
    .participant {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        border-bottom: 1px solid #f1f1f1;
        transition: background-color 0.2s;
    }
    
    .participant:hover {
        background-color: #f8f9fa;
    }
    
    .participant-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #4a6bff 0%, #2541b2 100%);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        margin-right: 12px;
    }
    
    .participant-info {
        flex: 1;
    }
    
    .participant-name {
        font-weight: 500;
        margin-bottom: 2px;
    }
    
    .participant-status {
        font-size: 0.75rem;
        color: #28a745;
    }
    
    .connection-status {
        transition: all 0.3s;
        border-radius: 30px;
        font-size: 0.85rem;
        padding: 8px 15px;
    }
    
    /* Video Call Styles */
    .local-video-container {
        position: relative;
        width: 100%;
        border-radius: 8px;
        overflow: hidden;
    }
    
    #localVideo {
        width: 100%;
        border-radius: 8px;
        transform: scaleX(-1); /* Mirror effect */
        background-color: #333;
        min-height: 150px;
    }
    
    .remote-videos {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }
    
    .remote-video {
        width: 100%;
        max-width: 300px;
        border-radius: 8px;
        background-color: #333;
        min-height: 150px;
    }
    
    .video-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
    }
    
    /* Whiteboard Styles */
    #whiteboard {
        width: 100%;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: white;
        min-height: 300px;
    }
    
    /* Animation */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .message {
        animation: fadeIn 0.3s ease-out;
    }
</style>
{% endblock %}

{% block content %}
<div class="container my-4">
    <!-- Meeting Header -->
    <div class="meeting-container">
        <div class="meeting-header">
            <h2 class="meeting-title">{{ reservation.title }}</h2>
            <p class="meeting-info">
                <i class="far fa-calendar-alt me-2"></i>{{ reservation.date }} 
                <i class="far fa-clock ms-3 me-2"></i>{{ reservation.start_time }} - {{ reservation.end_time }}
                <i class="far fa-building ms-3 me-2"></i>{{ reservation.room.name }}
            </p>
            <div class="meeting-actions">
                <button class="btn btn-sm btn-light" id="leave-btn">
                    <i class="fas fa-sign-out-alt me-1"></i> Leave Meeting
                </button>
            </div>
        </div>
    </div>
    
    <div class="row">
        <!-- Video Call and Whiteboard Column -->
        <div class="col-lg-8 mb-4">
            <!-- Video Call Section -->
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5><i class="fas fa-video me-2"></i>Video Call</h5>
                    <div>
                        <button id="startCall" class="btn btn-success btn-sm">
                            <i class="fas fa-phone"></i> Start Video Call
                        </button>
                        <button id="endCall" class="btn btn-danger btn-sm" style="display: none;">
                            <i class="fas fa-phone-slash"></i> End Call
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="videocall-container" 
                         data-reservation-id="{{ reservation.id }}" 
                         data-current-user-id="{{ request.user.id }}">
                        <div class="row">
                            <div class="col-md-4">
                                <div class="local-video-container">
                                    <video id="localVideo" autoplay playsinline muted></video>
                                    <div class="video-label">You</div>
                                </div>
                            </div>
                            <div class="col-md-8">
                                <div id="remoteVideos" class="remote-videos"></div>
                            </div>
                        </div>
                        <div id="videoCallControls" class="mt-3 d-flex justify-content-center" style="display: none;">
                            <button id="toggleCamera" class="btn btn-light mx-2">
                                <i class="fas fa-video"></i>
                            </button>
                            <button id="toggleMic" class="btn btn-light mx-2">
                                <i class="fas fa-microphone"></i>
                            </button>
                            <button id="startShare" class="btn btn-light mx-2">
                                <i class="fas fa-desktop"></i> Share Screen
                            </button>
                            <button id="stopShare" class="btn btn-danger mx-2" style="display: none;">
                                <i class="fas fa-stop"></i> Stop Sharing
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Screen Share Section -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5><i class="fas fa-desktop me-2"></i>Screen Sharing</h5>
                </div>
                <div class="card-body">
                    <video id="screenShareVideo" style="display: none; width: 100%;" autoplay></video>
                </div>
            </div>
            
            <!-- Whiteboard Section -->
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5><i class="fas fa-chalkboard me-2"></i>Whiteboard</h5>
                    <div>
                        <button id="pencilTool" class="btn btn-sm btn-outline-secondary">
                            <i class="fas fa-pencil-alt"></i>
                        </button>
                        <button id="eraserTool" class="btn btn-sm btn-outline-secondary">
                            <i class="fas fa-eraser"></i>
                        </button>
                        <input type="color" id="colorPicker" value="#000000" class="form-control-sm">
                        <input type="range" id="brushSize" min="1" max="20" value="5" class="form-control-sm">
                        <button id="clearBoard" class="btn btn-sm btn-outline-danger">
                            <i class="fas fa-trash"></i>
                        </button>
                        <button id="saveBoard" class="btn btn-sm btn-outline-primary">
                            <i class="fas fa-save"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body p-0">
                    <canvas id="whiteboard" height="400"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Chat and Participants Column -->
        <div class="col-lg-4 mb-4">
            <!-- Chat Section -->
            <div class="chat-container mb-4">
                <div class="chat-header">
                    <i class="fas fa-comments me-2"></i> Group Chat
                </div>
                
                <div class="chat-messages" id="chat-log">
                    <!-- Chat messages will be displayed here -->
                </div>
                
                <div class="chat-input-container">
                    <div id="connection-status" class="connection-status alert alert-info mb-3">
                        <i class="fas fa-circle-notch fa-spin me-2"></i> Connecting to chat...
                    </div>
                    
                    <form id="chat-form">
                        <div class="input-group">
                            <input type="text" id="chat-message-input" class="form-control chat-input" 
                                   placeholder="Type a message..." autocomplete="off">
                            <button type="submit" id="chat-message-submit" class="btn btn-primary chat-send-btn">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </form>
                </div>
            </div>
            
            <!-- Participants Section -->
            <div class="participants-container">
                <div class="participants-header">
                    <i class="fas fa-users me-2"></i> Participants <span id="participant-count" class="badge bg-primary ms-2">1</span>
                </div>
                
                <div class="participants-list" id="user-list">
                    <!-- Participants will be displayed here -->
                    <div class="participant">
                        <div class="participant-avatar">
                            {{ request.user.username|slice:":1"|upper }}
                        </div>
                        <div class="participant-info">
                            <div class="participant-name">{{ request.user.username }} (You)</div>
                            <div class="participant-status">Online</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const reservationId = "{{ reservation.id }}";
    const username = "{{ request.user.username }}";
    const userId = "{{ request.user.id }}";
    const ROOM_ID = reservationId;
    const CURRENT_USER = {
        id: userId,
        username: username
    };
    
    // Participants tracking
    const participants = new Map();
    participants.set(userId, username);
    
    // DOM Elements
    const chatLog = document.getElementById('chat-log');
    const chatMessageInput = document.getElementById('chat-message-input');
    const chatForm = document.getElementById('chat-form');
    const messageSubmit = document.getElementById('chat-message-submit');
    const connectionStatus = document.getElementById('connection-status');
    const userList = document.getElementById('user-list');
    const participantCount = document.getElementById('participant-count');
    const leaveBtn = document.getElementById('leave-btn');
    const startCallBtn = document.getElementById('startCall');
    const endCallBtn = document.getElementById('endCall');
    const videoCallControls = document.getElementById('videoCallControls');
    const toggleCameraBtn = document.getElementById('toggleCamera');
    const toggleMicBtn = document.getElementById('toggleMic');
    const startShareBtn = document.getElementById('startShare');
    const stopShareBtn = document.getElementById('stopShare');
    const screenShareVideo = document.getElementById('screenShareVideo');
    const localVideo = document.getElementById('localVideo');
    const remoteVideos = document.getElementById('remoteVideos');

    // WebSocket and WebRTC variables
    let chatSocket = null;
    let localStream = null;
    let screenStream = null;
    let peerConnections = {};
    let whiteboardHistory = [];

    function sendWhiteboardData(recipient_id) {
    if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
        chatSocket.send(JSON.stringify({
            'type': 'whiteboard_history',
            'recipient_id': recipient_id,
            'history': whiteboardHistory
        }));
    }
}


    // Initialize WebSocket
    function initializeWebSocket() {
        // Determine protocol based on current page
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const socketUrl = `${protocol}${window.location.host}/ws/chat/${reservationId}/`;

        try {
            chatSocket = new WebSocket(socketUrl);

            chatSocket.onopen = function(e) {
                console.log('WebSocket connection established');
                connectionStatus.innerHTML = '<i class="fas fa-check-circle me-2"></i> Connected to chat';
                connectionStatus.classList.remove('alert-info');
                connectionStatus.classList.add('alert-success');
                
                // Hide status after 3 seconds
                setTimeout(() => {
                    connectionStatus.style.display = 'none';
                }, 3000);
            };

            chatSocket.onmessage = handleWebSocketMessage;
            chatSocket.onclose = handleWebSocketClose;
            chatSocket.onerror = handleWebSocketError;

        } catch (error) {
            console.error('WebSocket initialization error:', error);
            displaySystemMessage('Failed to establish WebSocket connection');
        }
    }
    const roomActivities = {
    callActive: false,
    screenShareActive: false,
    whiteboardInUse: false
};
    // Handle WebSocket messages
    function handleWebSocketMessage(e) {
        console.log('Message received:', e.data);
        const data = JSON.parse(e.data);
        
        switch(data.type) {
            // In the handleWebSocketMessage function, add these cases:

            case 'whiteboard_history':
                if (data.recipient_id === userId && data.history) {
                    data.history.forEach(stroke => {
                        if (window.handleWhiteboardData) {
                            window.handleWhiteboardData(stroke);
                        }
                    });
                }
                break;

            case 'user_join':
                addParticipant(data.user_id, data.username);

                if (userId === data.user_id) {
                    displaySystemMessage('You joined the meeting');
                } 
                else {
                    if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                        chatSocket.send(JSON.stringify({
                            'type': 'room_status',
                            'recipient_id': data.user_id,
                            'call_active': localStream !== null,
                            'screen_share_active': screenStream !== null
                        }));
                    }
                }

                if(whiteboardHistory>0){
                    sendWhiteboardData(data.user_id);
                }

                if (userId === data.user_id) {
                    if(localStream){
                        const pc = createPeerConnection(data.user_id);

                        pc.createOffer()
                            .then(offer => {
                                return pc.setLocalDescription(offer);
                            })
                            .then(() => {

                                if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                                    chatSocket.send(JSON.stringify({
                                        'type': 'offer',
                                        'offer': pc.localDescription,
                                        'recipient_id': data.user_id,
                                        'sender_id': userId
                                    }));
                                }

                            });
                    }
            }
                break ;
            
            case 'room_status':
                if(data.recipient_id === userId) {
                    if(data.call_active){
                        displaySystemMessage('A video call is active');
                        const joinCallBtn = document.createElement('button');
                        joinCallBtn.className = 'btn btn-success btn-sm mt-2';
                        joinCallBtn.innerHTML = '<i class="fas fa-phone"></i> Join Call';
                        joinCallBtn.onclick = startCall;

                        const joinCallMessage = document.createElement('div');
                        joinCallMessage.className = 'message-system';
                        joinCallMessage.appendChild(joinCallBtn);

                        chatLog.appendChild(joinCallMessage);
                        scrollToBottom();
                    }
                    if(data.screen_share_active){
                        displaySystemMessage('Screen sharing is active');
                    }
                }
                break;

            case 'whiteboard_data':
                if (window.handleWhiteboardData) {
                    window.handleWhiteboardData(data.data);
                }
                break;

            case 'whiteboard_clear':
                if (window.handleWhiteboardClear) {
                    window.handleWhiteboardClear();
                }
                break;

            case 'chat_message':
                const isCurrentUser = data.user_id === userId;
                displayMessage(
                    data.message, 
                    data.username, 
                    isCurrentUser, 
                    new Date(data.timestamp)
                );
                break;
            
            case 'fetch_messages':
                // Handle loading previous messages
                data.messages.forEach(msg => {
                    displayMessage(
                        msg.message, 
                        msg.username, 
                        msg.userId === userId, 
                        new Date(msg.timestamp)
                    );
                });
                break;
            // In the handleWebSocketMessage function, add this case:
            case 'start_call':

                displaySystemMessage(`${data.username} started a video call`);
                if (!localStream && data.user_id !== userId) {
                    // Prompt the user to join the call
                    if (confirm(`${data.username} started a video call. Would you like to join?`)) {
                        startCall();
                    }
                }
                break;
            
            case 'user_leave':
                removeParticipant(data.user_id);
                break;
            
            case 'error':
                displaySystemMessage('Error: ' + data.message);
                break;
                
            // WebRTC signaling messages
            case 'offer':
                handleOffer(data);
                break;
                
            case 'answer':
                handleAnswer(data);
                break;
                
            case 'ice_candidate':
                handleIceCandidate(data);
                break;
            
            case 'start_screen_share':
                displaySystemMessage(`${data.username} started screen sharing`);
                break;
                
            case 'stop_screen_share':
                displaySystemMessage(`${data.username} stopped screen sharing`);
                break;
        }
    }

    // WebSocket event handlers
    function handleWebSocketClose(e) {
        console.log('WebSocket connection closed');
        connectionStatus.innerHTML = '<i class="fas fa-times-circle me-2"></i> Disconnected from chat';
        connectionStatus.classList.remove('alert-success', 'alert-info');
        connectionStatus.classList.add('alert-danger');
        connectionStatus.style.display = 'block';
        
        displaySystemMessage('Disconnected from chat. Refresh the page to reconnect.');
    }

    function handleWebSocketError(e) {
        console.error('WebSocket error:', e);
        connectionStatus.innerHTML = '<i class="fas fa-exclamation-triangle me-2"></i> Connection error';
        connectionStatus.classList.remove('alert-success', 'alert-info');
        connectionStatus.classList.add('alert-danger');
        connectionStatus.style.display = 'block';
        
        displaySystemMessage('Connection error occurred');
    }

    // Display message in chat log
    function displayMessage(message, sender, isCurrentUser = false, timestamp = new Date()) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${isCurrentUser ? 'message-mine' : 'message-others'}`;
        
        let messageContent = '';
        
        if (!isCurrentUser) {
            messageContent += `<div class="message-sender">${sender}</div>`;
        }
        
        messageContent += `
            <div class="message-content">${message}</div>
            <div class="message-time">${formatTime(timestamp)}</div>
        `;
        
        messageElement.innerHTML = messageContent;
        chatLog.appendChild(messageElement);
        scrollToBottom();
    }

    // Display system message
    function displaySystemMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.className = 'message-system';
        messageElement.textContent = message;
        
        chatLog.appendChild(messageElement);
        scrollToBottom();
    }

    // Scroll chat to bottom
    function scrollToBottom() {
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Format timestamp
    function formatTime(date) {
        if (typeof date === 'string') {
            date = new Date(date);
        }
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Update participants list
    function updateParticipantsList() {
        userList.innerHTML = '';
        
        participants.forEach((username, id) => {
            const isCurrentUser = id === userId;
            
            const participantElement = document.createElement('div');
            participantElement.className = 'participant';
            participantElement.setAttribute('data-user-id', id);
            
            participantElement.innerHTML = `
                <div class="participant-avatar">
                    ${username.charAt(0).toUpperCase()}
                </div>
                <div class="participant-info">
                    <div class="participant-name">${username} ${isCurrentUser ? '(You)' : ''}</div>
                    <div class="participant-status">Online</div>
                </div>
            `;
            
            userList.appendChild(participantElement);
        });
        
        // Update participant count
        participantCount.textContent = participants.size;
    }

    // Add participant
    function addParticipant(id, name) {
        if (!participants.has(id)) {
            participants.set(id, name);
            updateParticipantsList();
            displaySystemMessage(`${name} joined the meeting`);
        }
    }

    // Remove participant
    function removeParticipant(id) {
        if (participants.has(id)) {
            const name = participants.get(id);
            participants.delete(id);
            updateParticipantsList();
            displaySystemMessage(`${name} left the meeting`);
        }
    }

    // Send message form submission
    function sendMessage() {
        const message = chatMessageInput.value.trim();
        if (message && chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            // Send message to server
            chatSocket.send(JSON.stringify({
                'message': message
            }));
            
            chatMessageInput.value = '';
            chatMessageInput.focus();
        }
    }

    chatForm.addEventListener('submit', function(e) {
        e.preventDefault();
        sendMessage();
    });

    messageSubmit.addEventListener('click', function(e) {
        e.preventDefault();
        sendMessage();
    });

    chatMessageInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            sendMessage();
        }
    });

    // Video Call Functions
    // Modify the startCall function

    async function startCall() {

        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
            
            endCallBtn.style.display = 'inline-block';
            startCallBtn.style.display = 'none';
            videoCallControls.style.display = 'flex';
            
            // Notify other participants
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    'type': 'start_call',
                    'user_id': userId,
                    'username': username
                }));
            }
            
            // Create peer connections with existing participants
            participants.forEach((name, id) => {
                if (id !== userId) {
                    createPeerConnection(id);
                }
            });
            
        } catch (error) {
            console.error('Error starting video call:', error);
            displaySystemMessage('Failed to access camera or microphone');
        }
    }

    function endCall() {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localVideo.srcObject = null;
        }
        
        // Close all peer connections
        Object.values(peerConnections).forEach(pc => pc.close());
        peerConnections = {};
        
        // Clear remote videos
        remoteVideos.innerHTML = '';
        
        endCallBtn.style.display = 'none';
        startCallBtn.style.display = 'inline-block';
        videoCallControls.style.display = 'none';
        
        // Notify other participants
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                'type': 'end_call'
            }));
        }
    }

    function toggleCamera() {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                
                if (videoTrack.enabled) {
                    toggleCameraBtn.innerHTML = '<i class="fas fa-video"></i>';
                } else {
                    toggleCameraBtn.innerHTML = '<i class="fas fa-video-slash"></i>';
                }
            }
        }
    }

    function toggleMic() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                
                if (audioTrack.enabled) {
                    toggleMicBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                } else {
                    toggleMicBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                }
            }
        }
    }

    // Screen Sharing Functions
    async function startScreenShare() {
        try {
            screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            screenShareVideo.srcObject = screenStream;
            screenShareVideo.style.display = 'block';
            
            startShareBtn.style.display = 'none';
            stopShareBtn.style.display = 'inline-block';
            
            // Event listener for when user stops sharing via browser UI
            screenStream.getVideoTracks()[0].addEventListener('ended', stopScreenShare);
            
            // Notify other participants
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    'type': 'start_screen_share'
                }));
            }
            
        } catch (error) {
            console.error('Error starting screen share:', error);
            displaySystemMessage('Failed to share screen');
        }
    }

    function stopScreenShare() {
        if (screenStream) {
            screenStream.getTracks().forEach(track => track.stop());
            screenShareVideo.srcObject = null;
            screenShareVideo.style.display = 'none';
        }
        
        startShareBtn.style.display = 'inline-block';
        stopShareBtn.style.display = 'none';
        
        // Notify other participants
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                'type': 'stop_screen_share'
            }));
        }
    }

    // Whiteboard Functions
    function initializeWhiteboard() {
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const pencilTool = document.getElementById('pencilTool');
        const eraserTool = document.getElementById('eraserTool');
        const clearBoard = document.getElementById('clearBoard');
        const saveBoard = document.getElementById('saveBoard');
        
        // Set canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 400;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Drawing variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pencil';
        
        // Tool selection
        pencilTool.addEventListener('click', () => {
            currentTool = 'pencil';
            pencilTool.classList.add('active');
            eraserTool.classList.remove('active');
        });
        
        eraserTool.addEventListener('click', () => {
            currentTool = 'eraser';
            eraserTool.classList.add('active');
            pencilTool.classList.remove('active');
        });
        
        // Drawing functions
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            
            if (currentTool === 'pencil') {
                ctx.strokeStyle = colorPicker.value;
            } else if (currentTool === 'eraser') {
                ctx.strokeStyle = '#FFFFFF';
            }
            
            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // Store current points for WebSocket transmission
            const currentX = e.offsetX;
            const currentY = e.offsetY;
            
            // Send drawing data to server
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    'type': 'whiteboard_data',
                    'data': {
                        fromX: lastX,
                        fromY: lastY,
                        toX: currentX,
                        toY: currentY,
                        color: ctx.strokeStyle,
                        lineWidth: ctx.lineWidth,
                        tool: currentTool
                    }
                }));
            }
            
            // Update last position
            [lastX, lastY] = [currentX, currentY];
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        // Clear whiteboard
        clearBoard.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the whiteboard?')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Notify other participants
                if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                    chatSocket.send(JSON.stringify({
                        'type': 'whiteboard_clear'
                    }));
                }
            }
        });
        
        // Save whiteboard as image
        saveBoard.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'whiteboard.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
        
        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup');
            canvas.dispatchEvent(mouseEvent);
        });
        
        // Handle received whiteboard data
        window.handleWhiteboardData = function(data) {
            ctx.beginPath();
            ctx.moveTo(data.fromX, data.fromY);
            ctx.lineTo(data.toX, data.toY);
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.lineWidth;
            ctx.lineCap = 'round';
            ctx.stroke();
        };
        
        window.handleWhiteboardClear = function() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };
    }
    
    // WebRTC Functions
    function createPeerConnection(remotePeerId) {
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    
    const peerConnection = new RTCPeerConnection(configuration);
    peerConnections[remotePeerId] = peerConnection;
    
    // Add local tracks to the connection
    if (localStream) {
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
    }
    
    // Handle ICE candidates
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    'type': 'ice_candidate',
                    'candidate': event.candidate,
                    'recipient_id': remotePeerId,
                    'sender_id': userId
                }));
            }
        }
    };
    
    // Handle incoming tracks
    peerConnection.ontrack = event => {
        console.log(`Received tracks from peer ${remotePeerId}`);
        
        // Remove any existing video element for this peer
        const existingContainer = document.getElementById(`remote-video-${remotePeerId}`);
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create container for remote video
        const remoteVideoContainer = document.createElement('div');
        remoteVideoContainer.className = 'remote-video-container';
        remoteVideoContainer.id = `remote-video-${remotePeerId}`;
        
        // Create video element
        const remoteVideo = document.createElement('video');
        remoteVideo.className = 'remote-video';
        remoteVideo.autoplay = true;
        remoteVideo.playsInline = true;
        remoteVideo.srcObject = event.streams[0];
        
        // Create video label
        const videoLabel = document.createElement('div');
        videoLabel.className = 'video-label';
        videoLabel.textContent = participants.get(remotePeerId) || 'Unknown';
        
        remoteVideoContainer.appendChild(remoteVideo);
        remoteVideoContainer.appendChild(videoLabel);
        remoteVideos.appendChild(remoteVideoContainer);
    };
    
    return peerConnection;
}
    
    // Handle WebRTC offers
    function handleOffer(data) {
        const remotePeerId = data.sender_id;
        
        // Create peer connection if it doesn't exist
        if (!peerConnections[remotePeerId]) {
            const peerConnection = createPeerConnection(remotePeerId);
            
            // Set remote description and create answer
            peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer))
                .then(() => peerConnection.createAnswer())
                .then(answer => peerConnection.setLocalDescription(answer))
                .then(() => {
                    if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                        chatSocket.send(JSON.stringify({
                            'type': 'answer',
                            'answer': peerConnection.localDescription,
                            'recipient_id': remotePeerId
                        }));
                    }
                })
                .catch(error => console.error('Error handling offer:', error));
        }
    }
    
    // Handle WebRTC answers
    function handleAnswer(data) {
        const remotePeerId = data.sender_id;
        const peerConnection = peerConnections[remotePeerId];
        
        if (peerConnection) {
            peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer))
                .catch(error => console.error('Error handling answer:', error));
        }
    }
    
    // Handle ICE candidates
    function handleIceCandidate(data) {

        const remotePeerId = data.sender_id;
        const peerConnection = peerConnections[remotePeerId];
        
        if (peerConnection) {
            try {
                peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate))
                    .catch(error => console.error('Error adding ICE candidate:', error));
            } catch (e) {
                console.error('Error processing ICE candidate:', e);
            }
        } else {
            console.warn('Received ICE candidate for non-existent peer connection:', remotePeerId);
            // Store the candidate for later use when the connection is created
            if (!pendingIceCandidates[remotePeerId]) {
                pendingIceCandidates[remotePeerId] = [];
            }
            pendingIceCandidates[remotePeerId].push(data.candidate);
        }
    }
    
    function initiateConnectionsWithAllUsers() {
    participants.forEach((name, id) => {
        if (id !== userId && !peerConnections[id]) {
            const pc = createPeerConnection(id);
            
            // Only the call initiator creates offers
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => {
                    if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                        chatSocket.send(JSON.stringify({
                            'type': 'offer',
                            'offer': pc.localDescription,
                            'recipient_id': id,
                            'sender_id': userId
                        }));
                    }
                })
                .catch(error => console.error('Error creating offer:', error));
        }
    });
}
    // Leave meeting button
    leaveBtn.addEventListener('click', function() {
        if (confirm('Are you sure you want to leave this meeting?')) {
            // End ongoing calls and screen shares
            endCall();
            stopScreenShare();
            
            // Close WebSocket
            if (chatSocket) {
                chatSocket.close();
            }
            
            // Redirect to home
            window.location.href = '/';
        }
    });
    
    // Event listeners for video call controls
    startCallBtn.addEventListener('click', startCall);
    endCallBtn.addEventListener('click', endCall);
    toggleCameraBtn.addEventListener('click', toggleCamera);
    toggleMicBtn.addEventListener('click', toggleMic);
    startShareBtn.addEventListener('click', startScreenShare);
    stopShareBtn.addEventListener('click', stopScreenShare);
    
    // Initialize WebSocket and whiteboard when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initializeWebSocket();
        initializeWhiteboard();
    });
</script>
{% endblock %}